-- Harden profile photo trust model so only server-side verification can grant booking trust.

ALTER TABLE public.profiles
  ADD COLUMN IF NOT EXISTS profile_photo_source TEXT,
  ADD COLUMN IF NOT EXISTS profile_photo_captured_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS profile_photo_capture_verified BOOLEAN NOT NULL DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS profile_photo_last_changed_at TIMESTAMPTZ;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'profiles_profile_photo_source_check'
      AND conrelid = 'public.profiles'::regclass
  ) THEN
    ALTER TABLE public.profiles
      ADD CONSTRAINT profiles_profile_photo_source_check
      CHECK (profile_photo_source IN ('in_app_camera', 'legacy_import', 'unknown'));
  END IF;
END
$$;

ALTER TABLE public.profiles
  ALTER COLUMN profile_photo_source SET DEFAULT 'in_app_camera';

UPDATE public.profiles
SET profile_photo_source = CASE
  WHEN avatar_url IS NULL THEN 'in_app_camera'
  ELSE 'legacy_import'
END
WHERE profile_photo_source IS NULL;

ALTER TABLE public.profiles
  ALTER COLUMN profile_photo_source SET NOT NULL;

UPDATE public.profiles
SET profile_photo_last_changed_at = COALESCE(
  profile_photo_last_changed_at,
  profile_photo_id_match_attested_at,
  id_verified_at,
  updated_at,
  created_at,
  NOW()
)
WHERE avatar_url IS NOT NULL
  AND profile_photo_last_changed_at IS NULL;

UPDATE public.profiles
SET profile_photo_captured_at = COALESCE(
  profile_photo_captured_at,
  profile_photo_last_changed_at,
  updated_at,
  NOW()
)
WHERE avatar_url IS NOT NULL
  AND profile_photo_captured_at IS NULL;

UPDATE public.profiles
SET profile_photo_capture_verified = TRUE
WHERE avatar_url IS NOT NULL
  AND COALESCE(profile_photo_id_match_attested, FALSE) = TRUE
  AND COALESCE(profile_photo_capture_verified, FALSE) = FALSE;

UPDATE public.profiles
SET profile_photo_capture_verified = FALSE,
    profile_photo_captured_at = NULL,
    profile_photo_last_changed_at = NULL
WHERE avatar_url IS NULL;

CREATE TABLE IF NOT EXISTS public.profile_photo_capture_audit (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  captured_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  source TEXT NOT NULL,
  avatar_url TEXT,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);

CREATE INDEX IF NOT EXISTS idx_profile_photo_capture_audit_user_time
  ON public.profile_photo_capture_audit(user_id, captured_at DESC);

ALTER TABLE public.profile_photo_capture_audit ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'profile_photo_capture_audit'
      AND policyname = 'Users can view own profile photo capture audit'
  ) THEN
    CREATE POLICY "Users can view own profile photo capture audit"
      ON public.profile_photo_capture_audit
      FOR SELECT
      USING (auth.uid() = user_id);
  END IF;
END
$$;

CREATE OR REPLACE FUNCTION public.enforce_profile_photo_trust_fields_v1()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  privileged_actor BOOLEAN := current_user IN ('postgres', 'service_role', 'supabase_admin', 'supabase_functions_admin');
BEGIN
  IF NEW.avatar_url IS DISTINCT FROM OLD.avatar_url THEN
    NEW.profile_photo_source := 'in_app_camera';
    NEW.profile_photo_captured_at := NOW();
    NEW.profile_photo_last_changed_at := NOW();
    NEW.profile_photo_capture_verified := FALSE;
    NEW.profile_photo_id_match_attested := FALSE;
    NEW.profile_photo_id_match_attested_at := NULL;

    INSERT INTO public.profile_photo_capture_audit (
      user_id,
      captured_at,
      source,
      avatar_url,
      metadata
    )
    VALUES (
      NEW.id,
      NOW(),
      'in_app_camera',
      NEW.avatar_url,
      jsonb_build_object('trigger', 'profile_avatar_update')
    );
  END IF;

  IF NOT privileged_actor THEN
    IF NEW.profile_photo_capture_verified IS DISTINCT FROM OLD.profile_photo_capture_verified THEN
      NEW.profile_photo_capture_verified := OLD.profile_photo_capture_verified;
    END IF;

    IF NEW.profile_photo_id_match_attested IS DISTINCT FROM OLD.profile_photo_id_match_attested THEN
      NEW.profile_photo_id_match_attested := OLD.profile_photo_id_match_attested;
    END IF;

    IF NEW.profile_photo_id_match_attested_at IS DISTINCT FROM OLD.profile_photo_id_match_attested_at THEN
      NEW.profile_photo_id_match_attested_at := OLD.profile_photo_id_match_attested_at;
    END IF;

    IF NEW.avatar_url IS NOT DISTINCT FROM OLD.avatar_url THEN
      IF NEW.profile_photo_source IS DISTINCT FROM OLD.profile_photo_source THEN
        NEW.profile_photo_source := OLD.profile_photo_source;
      END IF;

      IF NEW.profile_photo_captured_at IS DISTINCT FROM OLD.profile_photo_captured_at THEN
        NEW.profile_photo_captured_at := OLD.profile_photo_captured_at;
      END IF;

      IF NEW.profile_photo_last_changed_at IS DISTINCT FROM OLD.profile_photo_last_changed_at THEN
        NEW.profile_photo_last_changed_at := OLD.profile_photo_last_changed_at;
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_enforce_profile_photo_trust_fields_v1 ON public.profiles;
CREATE TRIGGER trg_enforce_profile_photo_trust_fields_v1
  BEFORE UPDATE OF avatar_url, profile_photo_source, profile_photo_captured_at, profile_photo_capture_verified, profile_photo_last_changed_at, profile_photo_id_match_attested, profile_photo_id_match_attested_at
  ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.enforce_profile_photo_trust_fields_v1();

CREATE OR REPLACE FUNCTION public.mark_profile_photo_capture_verified_v1(
  p_blob_size_bytes INTEGER,
  p_capture_width INTEGER DEFAULT NULL,
  p_capture_height INTEGER DEFAULT NULL
)
RETURNS TABLE(
  success BOOLEAN,
  reason_code TEXT,
  reason_message TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  current_user_id UUID := auth.uid();
  profile_row public.profiles%ROWTYPE;
  recent_capture_count INTEGER := 0;
BEGIN
  IF current_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT *
  INTO profile_row
  FROM public.profiles
  WHERE id = current_user_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, 'PROFILE_NOT_FOUND', 'Profile not found.';
    RETURN;
  END IF;

  IF COALESCE(profile_row.avatar_url, '') = '' THEN
    RETURN QUERY SELECT FALSE, 'PROFILE_PHOTO_REQUIRED', 'Take a profile photo before starting verification.';
    RETURN;
  END IF;

  IF COALESCE(profile_row.profile_photo_source, '') <> 'in_app_camera' THEN
    RETURN QUERY SELECT FALSE, 'PHOTO_SOURCE_INVALID', 'Retake your profile photo in camera mode.';
    RETURN;
  END IF;

  IF p_blob_size_bytes IS NULL OR p_blob_size_bytes < 45000 THEN
    RETURN QUERY SELECT FALSE, 'PHOTO_TOO_LOW_QUALITY', 'Photo quality is too low. Retake with better lighting and framing.';
    RETURN;
  END IF;

  IF p_blob_size_bytes > 10485760 THEN
    RETURN QUERY SELECT FALSE, 'PHOTO_TOO_LARGE', 'Photo file is too large. Retake and try again.';
    RETURN;
  END IF;

  IF p_capture_width IS NOT NULL AND p_capture_width < 512 THEN
    RETURN QUERY SELECT FALSE, 'PHOTO_TOO_LOW_QUALITY', 'Photo resolution is too low. Retake with your face clearly visible.';
    RETURN;
  END IF;

  IF p_capture_height IS NOT NULL AND p_capture_height < 512 THEN
    RETURN QUERY SELECT FALSE, 'PHOTO_TOO_LOW_QUALITY', 'Photo resolution is too low. Retake with your face clearly visible.';
    RETURN;
  END IF;

  IF profile_row.profile_photo_captured_at IS NULL
    OR profile_row.profile_photo_captured_at < NOW() - INTERVAL '30 minutes' THEN
    RETURN QUERY SELECT FALSE, 'CAPTURE_TOO_OLD', 'Profile photo capture is too old. Retake your photo before verification.';
    RETURN;
  END IF;

  SELECT COUNT(*)
  INTO recent_capture_count
  FROM public.profile_photo_capture_audit
  WHERE user_id = current_user_id
    AND captured_at >= NOW() - INTERVAL '15 minutes';

  IF recent_capture_count > 8 THEN
    RETURN QUERY SELECT FALSE, 'CAPTURE_RATE_LIMITED', 'Too many retakes in a short period. Wait a few minutes and try again.';
    RETURN;
  END IF;

  UPDATE public.profiles
  SET profile_photo_capture_verified = TRUE,
      updated_at = NOW()
  WHERE id = current_user_id;

  RETURN QUERY SELECT TRUE, NULL::TEXT, NULL::TEXT;
END;
$$;

GRANT EXECUTE ON FUNCTION public.mark_profile_photo_capture_verified_v1(INTEGER, INTEGER, INTEGER) TO authenticated;

CREATE OR REPLACE FUNCTION public.has_trusted_profile_photo_for_booking(p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE SQL
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.profiles p
    WHERE p.id = p_user_id
      AND public.has_active_id_verification(p.id)
      AND COALESCE(p.profile_photo_capture_verified, FALSE) = TRUE
      AND COALESCE(p.profile_photo_id_match_attested, FALSE) = TRUE
      AND p.profile_photo_source = 'in_app_camera'
      AND p.profile_photo_captured_at IS NOT NULL
      AND p.profile_photo_last_changed_at IS NOT NULL
      AND p.profile_photo_id_match_attested_at IS NOT NULL
      AND p.id_verified_at IS NOT NULL
      AND p.profile_photo_id_match_attested_at >= p.profile_photo_last_changed_at
      AND p.id_verified_at >= p.profile_photo_last_changed_at
  );
$$;

GRANT EXECUTE ON FUNCTION public.has_trusted_profile_photo_for_booking(UUID) TO authenticated;

CREATE INDEX IF NOT EXISTS idx_profiles_photo_trust_state
  ON public.profiles(
    profile_photo_capture_verified,
    profile_photo_id_match_attested,
    profile_photo_last_changed_at,
    id_verified_at
  );

CREATE OR REPLACE FUNCTION public.get_companion_user_id(p_companion_id UUID)
RETURNS UUID
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT c.user_id
  FROM public.companions c
  WHERE c.id = p_companion_id
  LIMIT 1;
$$;

ALTER TABLE IF EXISTS public.bookings
  ADD COLUMN IF NOT EXISTS client_id UUID,
  ADD COLUMN IF NOT EXISTS companion_id UUID,
  ADD COLUMN IF NOT EXISTS conversation_id UUID REFERENCES public.conversations(id) ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'pending',
  ADD COLUMN IF NOT EXISTS date DATE,
  ADD COLUMN IF NOT EXISTS start_time TIME,
  ADD COLUMN IF NOT EXISTS duration_hours INTEGER,
  ADD COLUMN IF NOT EXISTS hourly_rate NUMERIC(10,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS subtotal NUMERIC(10,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS service_fee NUMERIC(10,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS total_price NUMERIC(10,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS location_name TEXT,
  ADD COLUMN IF NOT EXISTS location_address TEXT,
  ADD COLUMN IF NOT EXISTS location_place_id TEXT,
  ADD COLUMN IF NOT EXISTS location_latitude DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS location_longitude DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS location_lat DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS location_lng DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS activity_type TEXT,
  ADD COLUMN IF NOT EXISTS notes TEXT,
  ADD COLUMN IF NOT EXISTS meetup_status TEXT DEFAULT 'none',
  ADD COLUMN IF NOT EXISTS meetup_proposal_id UUID,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'bookings' AND column_name = 'user_id'
  ) THEN
    EXECUTE 'UPDATE public.bookings SET client_id = COALESCE(client_id, user_id) WHERE client_id IS NULL';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'bookings' AND column_name = 'booker_id'
  ) THEN
    EXECUTE 'UPDATE public.bookings SET client_id = COALESCE(client_id, booker_id) WHERE client_id IS NULL';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'bookings' AND column_name = 'provider_id'
  ) THEN
    EXECUTE 'UPDATE public.bookings SET companion_id = COALESCE(companion_id, provider_id) WHERE companion_id IS NULL';
  END IF;
END
$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'bookings_meetup_status_check_v1'
      AND conrelid = 'public.bookings'::regclass
  ) THEN
    ALTER TABLE public.bookings
      ADD CONSTRAINT bookings_meetup_status_check_v1
      CHECK (meetup_status IN ('none', 'proposed', 'countered', 'declined', 'agreed'));
  END IF;
END
$$;

CREATE TABLE IF NOT EXISTS public.meetup_location_proposals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
  booking_id UUID REFERENCES public.bookings(id) ON DELETE CASCADE,
  proposer_user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  place_id TEXT,
  place_name TEXT NOT NULL,
  place_address TEXT,
  latitude DOUBLE PRECISION,
  longitude DOUBLE PRECISION,
  note TEXT,
  status TEXT NOT NULL DEFAULT 'pending',
  response_by_user_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  response_note TEXT,
  responded_at TIMESTAMPTZ,
  supersedes_proposal_id UUID REFERENCES public.meetup_location_proposals(id) ON DELETE SET NULL,
  accepted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT meetup_location_proposals_status_check
    CHECK (status IN ('pending', 'accepted', 'declined', 'countered', 'withdrawn'))
);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'bookings_meetup_proposal_id_fkey'
      AND conrelid = 'public.bookings'::regclass
  ) THEN
    ALTER TABLE public.bookings
      ADD CONSTRAINT bookings_meetup_proposal_id_fkey
      FOREIGN KEY (meetup_proposal_id)
      REFERENCES public.meetup_location_proposals(id)
      ON DELETE SET NULL
      DEFERRABLE INITIALLY DEFERRED;
  END IF;
EXCEPTION
  WHEN undefined_column THEN
    NULL;
END
$$;

CREATE OR REPLACE FUNCTION public.create_booking_with_meetup_v1(
  p_companion_id UUID,
  p_date DATE,
  p_start_time TIME,
  p_duration_hours INTEGER,
  p_hourly_rate NUMERIC,
  p_location_name TEXT,
  p_location_address TEXT DEFAULT NULL,
  p_place_id TEXT DEFAULT NULL,
  p_location_latitude DOUBLE PRECISION DEFAULT NULL,
  p_location_longitude DOUBLE PRECISION DEFAULT NULL,
  p_activity_type TEXT DEFAULT NULL,
  p_notes TEXT DEFAULT NULL,
  p_conversation_id UUID DEFAULT NULL,
  p_meetup_note TEXT DEFAULT NULL
)
RETURNS public.bookings
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  current_user_id UUID := auth.uid();
  companion_user_id UUID;
  resolved_conversation_id UUID;
  booking_row public.bookings;
  proposal_row public.meetup_location_proposals;
  subtotal NUMERIC;
  service_fee NUMERIC;
BEGIN
  IF current_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_companion_id IS NULL OR p_date IS NULL OR p_start_time IS NULL THEN
    RAISE EXCEPTION 'Missing required booking fields';
  END IF;

  IF COALESCE(TRIM(p_location_name), '') = '' AND COALESCE(TRIM(p_place_id), '') = '' THEN
    RAISE EXCEPTION 'Meetup location is required';
  END IF;

  SELECT c.user_id
  INTO companion_user_id
  FROM public.companions c
  WHERE c.id = p_companion_id
  LIMIT 1;

  IF companion_user_id IS NULL THEN
    RAISE EXCEPTION 'Companion not found';
  END IF;

  IF public.are_users_blocked(current_user_id, companion_user_id) THEN
    RAISE EXCEPTION 'Unable to create booking';
  END IF;

  IF NOT public.has_active_id_verification(current_user_id) THEN
    RAISE EXCEPTION 'ID_VERIFICATION_REQUIRED'
      USING ERRCODE = 'P0001',
            DETAIL = 'Your ID verification is expired or incomplete. Re-verify to continue booking.';
  END IF;

  IF NOT public.has_active_id_verification(companion_user_id) THEN
    RAISE EXCEPTION 'ID_VERIFICATION_REQUIRED'
      USING ERRCODE = 'P0001',
            DETAIL = 'This wingman cannot accept bookings until ID verification is renewed.';
  END IF;

  IF NOT public.has_trusted_profile_photo_for_booking(current_user_id) THEN
    RAISE EXCEPTION 'PHOTO_ID_REVERIFY_REQUIRED'
      USING ERRCODE = 'P0001',
            DETAIL = 'Retake your profile photo and complete ID verification again before booking.';
  END IF;

  IF NOT public.has_trusted_profile_photo_for_booking(companion_user_id) THEN
    RAISE EXCEPTION 'PHOTO_ID_REVERIFY_REQUIRED'
      USING ERRCODE = 'P0001',
            DETAIL = 'This wingman must refresh profile photo verification before accepting bookings.';
  END IF;

  IF p_conversation_id IS NOT NULL THEN
    SELECT c.id
    INTO resolved_conversation_id
    FROM public.conversations c
    WHERE c.id = p_conversation_id
      AND COALESCE(c.kind, 'direct') = 'direct'
      AND (
        (
          c.participant_ids @> ARRAY[current_user_id, companion_user_id]::UUID[]
          AND COALESCE(ARRAY_LENGTH(c.participant_ids, 1), 0) = 2
        )
        OR (
          c.participant_1 IN (current_user_id, companion_user_id)
          AND c.participant_2 IN (current_user_id, companion_user_id)
        )
      )
    LIMIT 1;
  END IF;

  IF resolved_conversation_id IS NULL THEN
    SELECT (public.get_or_create_direct_conversation_v2(companion_user_id)).id
    INTO resolved_conversation_id;
  END IF;

  subtotal := COALESCE(p_hourly_rate, 0) * GREATEST(COALESCE(p_duration_hours, 1), 1);
  service_fee := ROUND((subtotal * 0.10)::NUMERIC, 2);

  INSERT INTO public.bookings (
    client_id,
    companion_id,
    conversation_id,
    status,
    date,
    start_time,
    duration_hours,
    hourly_rate,
    subtotal,
    service_fee,
    total_price,
    location_name,
    location_address,
    location_place_id,
    location_latitude,
    location_longitude,
    location_lat,
    location_lng,
    activity_type,
    notes,
    meetup_status,
    created_at,
    updated_at
  ) VALUES (
    current_user_id,
    p_companion_id,
    resolved_conversation_id,
    'pending',
    p_date,
    p_start_time,
    GREATEST(COALESCE(p_duration_hours, 1), 1),
    COALESCE(p_hourly_rate, 0),
    subtotal,
    service_fee,
    subtotal + service_fee,
    COALESCE(NULLIF(TRIM(p_location_name), ''), 'Meetup location'),
    NULLIF(TRIM(p_location_address), ''),
    NULLIF(TRIM(p_place_id), ''),
    p_location_latitude,
    p_location_longitude,
    p_location_latitude,
    p_location_longitude,
    NULLIF(TRIM(p_activity_type), ''),
    NULLIF(TRIM(p_notes), ''),
    'proposed',
    NOW(),
    NOW()
  ) RETURNING * INTO booking_row;

  INSERT INTO public.meetup_location_proposals (
    conversation_id,
    booking_id,
    proposer_user_id,
    place_id,
    place_name,
    place_address,
    latitude,
    longitude,
    note,
    status,
    created_at,
    updated_at
  ) VALUES (
    resolved_conversation_id,
    booking_row.id,
    current_user_id,
    NULLIF(TRIM(p_place_id), ''),
    COALESCE(NULLIF(TRIM(p_location_name), ''), 'Meetup location'),
    NULLIF(TRIM(p_location_address), ''),
    p_location_latitude,
    p_location_longitude,
    NULLIF(TRIM(p_meetup_note), ''),
    'pending',
    NOW(),
    NOW()
  ) RETURNING * INTO proposal_row;

  UPDATE public.bookings
  SET meetup_proposal_id = proposal_row.id,
      updated_at = NOW()
  WHERE id = booking_row.id
  RETURNING * INTO booking_row;

  UPDATE public.conversations
  SET updated_at = NOW(),
      last_message_at = NOW(),
      last_message_preview = 'Proposed meetup location'
  WHERE id = resolved_conversation_id;

  RETURN booking_row;
END;
$$;

DROP POLICY IF EXISTS "Bookings require active id verification inserts v1" ON public.bookings;
CREATE POLICY "Bookings require active id verification inserts v1"
ON public.bookings
AS RESTRICTIVE
FOR INSERT
TO authenticated
WITH CHECK (
  client_id IS NULL
  OR (
    client_id = auth.uid()
    AND public.has_active_id_verification(client_id)
    AND public.has_trusted_profile_photo_for_booking(client_id)
    AND companion_id IS NOT NULL
    AND public.has_active_id_verification(public.get_companion_user_id(companion_id))
    AND public.has_trusted_profile_photo_for_booking(public.get_companion_user_id(companion_id))
  )
);

DROP POLICY IF EXISTS "Bookings require active id verification updates v1" ON public.bookings;
CREATE POLICY "Bookings require active id verification updates v1"
ON public.bookings
AS RESTRICTIVE
FOR UPDATE
TO authenticated
USING (
  client_id IS NULL
  OR (
    client_id = auth.uid()
    AND public.has_active_id_verification(client_id)
    AND public.has_trusted_profile_photo_for_booking(client_id)
    AND companion_id IS NOT NULL
    AND public.has_active_id_verification(public.get_companion_user_id(companion_id))
    AND public.has_trusted_profile_photo_for_booking(public.get_companion_user_id(companion_id))
  )
)
WITH CHECK (
  client_id IS NULL
  OR (
    client_id = auth.uid()
    AND public.has_active_id_verification(client_id)
    AND public.has_trusted_profile_photo_for_booking(client_id)
    AND companion_id IS NOT NULL
    AND public.has_active_id_verification(public.get_companion_user_id(companion_id))
    AND public.has_trusted_profile_photo_for_booking(public.get_companion_user_id(companion_id))
  )
);
